<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CA快速入门</title>
    <link href="/2025/11/25/1%E3%80%81CA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2025/11/25/1%E3%80%81CA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="CA端四步走"><a href="#CA端四步走" class="headerlink" title="CA端四步走"></a><strong>CA端四步走</strong></h2><h3 id="第一步：初始化环境"><a href="#第一步：初始化环境" class="headerlink" title="第一步：初始化环境"></a><strong>第一步：初始化环境</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">res = TEEC_InitializeContext(<span class="hljs-literal">NULL</span>, &amp;ctx);<br></code></pre></td></tr></table></figure><p>这句话在整个 OP-TEE 的流程中是 <strong>“万里长征第一步”</strong>。如果这步失败了，后面的所有操作（找 TA、发指令）全都会报错。</p><p>我们可以从三个维度来理解它：<strong>比喻维度</strong>、<strong>语法维度</strong>、<strong>底层维度</strong>。</p><hr><h3 id="1-比喻维度：走进银行大门"><a href="#1-比喻维度：走进银行大门" class="headerlink" title="1. 比喻维度：走进银行大门"></a>1. 比喻维度：走进银行大门</h3><ul><li><p><strong>动作</strong>：这行代码相当于你<strong>推开了银行的大门，站在了大堂里</strong>。</p></li><li><p><strong>状态</strong>：你还没有去具体的柜台（还没找 Session），你只是进入了“可以办理业务”的环境。</p></li><li><p><strong>结果</strong>：如果你成功进去了，银行大堂经理会发给你一张 <strong>“临时通行证”</strong>（也就是填好了的 <code>ctx</code> 变量）。以后你在银行里的所有活动，都要带着这张证。</p></li></ul><hr><h3 id="2-语法维度：参数拆解"><a href="#2-语法维度：参数拆解" class="headerlink" title="2. 语法维度：参数拆解"></a>2. 语法维度：参数拆解</h3><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">TEEC_Result <span class="hljs-title function_">TEEC_InitializeContext</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, TEEC_Context *context)</span>;<br></code></pre></td></tr></table></figure><p>我们来看看你传入的两个参数分别是什么意思：</p><h4 id="参数-1-NULL-name"><a href="#参数-1-NULL-name" class="headerlink" title="参数 1: NULL (name)"></a>参数 1: <code>NULL</code> (name)</h4><ul><li><p><strong>字面意思</strong>：名字。</p></li><li><p><strong>实际含义</strong>：你要连接哪一个 TEE OS？</p></li><li><p><strong>为什么填 NULL？</strong></p><ul><li><p>大多数嵌入式设备上（比如你的开发板或 QEMU），只有一个 TEE 环境（也就是 OP-TEE）。</p></li><li><p>填 <code>NULL</code> 的意思就是：“<strong>我不挑，就连那个默认的 TEE。</strong>”</p></li><li><p><em>注：极少数复杂的系统可能有多个 TEE，那时才需要填具体的名字，比如 “OP-TEE” 或 “Trusty”，但在 99% 的情况下，这里都是 NULL。</em></p></li></ul></li></ul><h4 id="参数-2-ctx-context"><a href="#参数-2-ctx-context" class="headerlink" title="参数 2: &amp;ctx (context)"></a>参数 2: <code>&amp;ctx</code> (context)</h4><ul><li><p><strong>字面意思</strong>：上下文（Context）的地址。</p></li><li><p><strong>实际含义</strong>：这是一个 <strong>“传出参数”</strong>（Output Parameter）。</p><ul><li><p>在调用函数前，<code>ctx</code> 是一个空的结构体，里面全是 0 或垃圾数据。类型是TEEC_Context</p></li><li><p>你把 <code>ctx</code> 的内存地址（<code>&amp;ctx</code>）告诉函数。</p></li><li><p>函数执行成功后，OP-TEE 的库（libteec）会把连接的底层细节（比如文件描述符）<strong>填写</strong>到这个结构体里。</p></li><li><p><strong>重点</strong>：这一步之后，<code>ctx</code> 就是那个 <strong>“通行证”</strong> 了，绝对不能丢，也不能随便改。</p></li></ul></li></ul><h4 id="返回值-res-result"><a href="#返回值-res-result" class="headerlink" title="返回值: res (result)"></a>返回值: <code>res</code> (result)</h4><ul><li><p>如果成功，<code>res</code> 会等于 <code>TEEC_SUCCESS</code> (0)。</p></li><li><p>如果失败（比如驱动没加载），它会返回一个非 0 的错误码。</p></li></ul><hr><h3 id="3-底层维度：到底发生了什么？（进阶理解）"><a href="#3-底层维度：到底发生了什么？（进阶理解）" class="headerlink" title="3. 底层维度：到底发生了什么？（进阶理解）"></a>3. 底层维度：到底发生了什么？（进阶理解）</h3><p>既然你在做复现，了解一点底层原理会让你对系统的理解更上一层楼。</p><p>当你运行这行代码时，Linux 用户空间（User Space）和内核空间（Kernel Space）发生了一次交互：</p><ol><li><p><strong>打开驱动文件</strong>：</p><ul><li><p>OP-TEE 在 Linux 中是一个驱动设备，通常位于 <code>/dev/tee0</code>。</p></li><li><p><code>TEEC_InitializeContext</code> 的内部实现，实际上是在调用 Linux 的 <code>open(&quot;/dev/tee0&quot;, ...)</code> 系统调用。</p></li></ul></li><li><p><strong>建立连接</strong>：</p><ul><li>如果 <code>/dev/tee0</code> 打开成功，Linux 内核里的 OP-TEE 驱动就会记录下：“嘿，有一个新的应用程序（你的 CA）连上来了。”</li></ul></li><li><p><strong>保存句柄</strong>：</p><ul><li><p><code>open</code> 函数会返回一个<strong>文件描述符 (File Descriptor, fd)</strong>。</p></li><li><p>这个 <code>fd</code> 会被悄悄地保存在 <code>ctx</code> 结构体的内部成员里（通常叫 <code>ctx-&gt;fd</code>）。</p></li><li><p>以后你调用 <code>TEEC_OpenSession</code> 时，库函数会直接去 <code>ctx</code> 里找这个 <code>fd</code>，通过它和内核说话。</p></li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>做什么</strong>：建立 CA 和 Linux TEE 驱动之间的通路。</p></li><li><p><strong>输入 <code>NULL</code></strong>：选默认的 TEE。</p></li><li><p><strong>输入 <code>&amp;ctx</code></strong>：给个空篮子，让函数把“连接句柄”放进去。</p></li><li><p><strong>底层</strong>：本质上就是 <code>open(&quot;/dev/tee0&quot;)</code>。</p></li></ul><h3 id="第二步：开启会话"><a href="#第二步：开启会话" class="headerlink" title="第二步：开启会话"></a><strong>第二步：开启会话</strong></h3><h3 id="1-代码再现"><a href="#1-代码再现" class="headerlink" title="1. 代码再现"></a>1. 代码再现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">TEEC_UUID uuid = TA_HELLO_WORLD_UUID; <span class="hljs-comment">// 1. 准备好 TA 的身份证号</span><br><br><span class="hljs-comment">/* 2. 发起会话连接 */</span><br>res = TEEC_OpenSession(&amp;ctx, &amp;sess, &amp;uuid,<br>                       TEEC_LOGIN_PUBLIC, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;err_origin);<br></code></pre></td></tr></table></figure><h3 id="2-参数拆解：这一行代码到底传了什么？"><a href="#2-参数拆解：这一行代码到底传了什么？" class="headerlink" title="2. 参数拆解：这一行代码到底传了什么？"></a>2. 参数拆解：这一行代码到底传了什么？</h3><p>这个函数参数有点多，但我们只需要关注其中 4 个核心参数：</p><h4 id="A-ctx-Context"><a href="#A-ctx-Context" class="headerlink" title="A. &amp;ctx (Context)"></a>A. <code>&amp;ctx</code> (Context)</h4><ul><li><p><strong>含义</strong>：你刚才在第一步拿到的“大厅通行证”。</p></li><li><p><strong>作用</strong>：告诉系统，“我是通过哪条线路进来的”。（底层就是用那个 <code>fd</code>）。</p></li></ul><h4 id="B-uuid-Destination"><a href="#B-uuid-Destination" class="headerlink" title="B. &amp;uuid (Destination)"></a>B. <code>&amp;uuid</code> (Destination)</h4><ul><li><p><strong>含义</strong>：<strong>我要找谁？</strong></p></li><li><p><strong>作用</strong>：这是我们在头文件里定义的那个长长的 16 进制数组。</p></li><li><p><strong>比喻</strong>：你在大厅里喊：“请问 <strong>8aaaf200…</strong> 号业务员在吗？”</p><ul><li>OP-TEE OS 收到请求后，会去查它的存储区域，找到文件名叫 <code>8aaaf200...ta</code> 的文件，把它加载进内存。</li></ul></li></ul><h4 id="C-sess-Session-——-新的主角"><a href="#C-sess-Session-——-新的主角" class="headerlink" title="C. &amp;sess (Session) —— 新的主角"></a>C. <code>&amp;sess</code> (Session) —— <strong>新的主角</strong></h4><ul><li><p><strong>含义</strong>：<strong>会话句柄</strong>（这也是一个“传出参数”）。</p></li><li><p><strong>作用</strong>：一旦连接成功，库函数会把这次“专线连接”的信息填在这个结构体里。</p></li><li><p><strong>重要区别</strong>：</p><ul><li><p><code>ctx</code> 是你和<strong>整个 TEE 系统</strong>的连接。</p></li><li><p><code>sess</code> 是你和<strong>这个特定 TA</strong> 的私聊通道。</p></li><li><p><em>以后发指令（InvokeCommand），用的是 <code>sess</code>，不再是 <code>ctx</code> 了。</em></p></li></ul></li></ul><h4 id="D-TEEC-LOGIN-PUBLIC-Connection-Method"><a href="#D-TEEC-LOGIN-PUBLIC-Connection-Method" class="headerlink" title="D. TEEC_LOGIN_PUBLIC (Connection Method)"></a>D. <code>TEEC_LOGIN_PUBLIC</code> (Connection Method)</h4><ul><li><p><strong>含义</strong>：<strong>我凭什么身份找你？</strong></p></li><li><p><strong>解释</strong>：这是 OP-TEE 的权限控制机制。</p><ul><li><p><code>TEEC_LOGIN_PUBLIC</code>：意思是“我是公众用户，我没啥特权，我就想办个普通业务”。这是最常用的，也是 <code>hello_world</code> 用的。</p></li><li><p><em>进阶知识</em>：如果 TA 处理的是高度敏感数据（比如指纹），它可能要求你提供 <code>TEEC_LOGIN_USER</code>（通过 Linux 用户 ID 验证），只有特定用户组的 Linux 进程才能连上它。</p></li></ul></li></ul><hr><h3 id="3-墙的另一边发生了什么？（关键）"><a href="#3-墙的另一边发生了什么？（关键）" class="headerlink" title="3. 墙的另一边发生了什么？（关键）"></a>3. 墙的另一边发生了什么？（关键）</h3><p>当你调用 <code>TEEC_OpenSession</code> 时，世界线发生了一次<strong>巨大的跳跃</strong>。</p><ol><li><p><strong>加载 (Loading)</strong>： OP-TEE OS 检查内存里有没有这个 TA。如果没有，它会从文件系统里把 TA 的二进制代码（<code>.ta</code> 文件）读出来，校验签名（确保没被篡改），然后运行它。</p></li><li><p><strong>握手 (Handshake)</strong>： TA 启动后，OP-TEE OS 会立刻调用 TA 里的一个回调函数： <strong><code>TA_OpenSessionEntryPoint</code></strong></p><ul><li><p><strong>如果 TA 代码里写了</strong>：“拒绝 Public 身份的用户连接”。</p><ul><li>那么 <code>TEEC_OpenSession</code> 会返回失败（Access Denied）。</li></ul></li><li><p><strong>如果 TA 代码里写了</strong>：“欢迎光临”。</p><ul><li>那么 <code>TEEC_OpenSession</code> 返回 <code>TEEC_SUCCESS</code>。</li></ul></li></ul></li></ol><hr><h3 id="4-那个-err-origin-是干嘛的？"><a href="#4-那个-err-origin-是干嘛的？" class="headerlink" title="4. 那个 err_origin 是干嘛的？"></a>4. 那个 <code>err_origin</code> 是干嘛的？</h3><p>你可能注意到了最后一个参数 <code>&amp;err_origin</code>。这玩意儿非常实用，它是用来<strong>甩锅</strong>的。</p><p>如果 <code>TEEC_OpenSession</code> 返回了失败（比如返回了 0xFFFF），你怎么知道是谁的问题？</p><ul><li><p>如果 <code>err_origin == TEEC_ORIGIN_API</code>：</p><ul><li><strong>你的问题</strong>。比如你传了个空指针，或者驱动没装好。</li></ul></li><li><p>如果 <code>err_origin == TEEC_ORIGIN_TEE</code>：</p><ul><li><strong>OP-TEE OS 的问题</strong>。比如系统内存不足了，或者找不到那个 UUID 的文件。</li></ul></li><li><p>如果 <code>err_origin == TEEC_ORIGIN_TRUSTED_APP</code>：</p><ul><li><strong>TA 的问题</strong>。系统帮你找到了 TA，但是 TA 的 <code>TA_OpenSessionEntryPoint</code> 函数里返回了错误（比如它不喜欢你的脸）。</li></ul></li></ul><h3 id="第三步：发送请求"><a href="#第三步：发送请求" class="headerlink" title="第三步：发送请求"></a><strong>第三步：发送请求</strong></h3><p>第三步是整个流程的高潮：<strong>业务办理（发送指令 &amp; 数据交互）</strong>。</p><p>如果说前两步只是“进大厅”和“坐到柜台前”，那么这一步就是你真正<strong>把填好的单子递进去</strong>，并看着柜员盖章签字的过程。</p><p>在代码中，这一步分为两个子动作：<strong>“填单子”</strong> (<code>TEEC_Operation</code>) 和 <strong>“递单子”</strong> (<code>TEEC_InvokeCommand</code>)。</p><hr><h3 id="子动作-A：填单子-TEEC-Operation"><a href="#子动作-A：填单子-TEEC-Operation" class="headerlink" title="子动作 A：填单子 (TEEC_Operation)"></a>子动作 A：填单子 (<code>TEEC_Operation</code>)</h3><p>OP-TEE 设计了一个非常严格的规则：你不能随便往里扔一堆烂数据。你必须把数据整理进一个叫 <code>TEEC_Operation</code> 的结构体里。</p><p>你可以把它想象成银行柜台的一个<strong>有 4 个凹槽的托盘</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">TEEC_Operation op;<br><span class="hljs-comment">/* 1. 清空托盘 (非常重要，防止里面有垃圾数据) */</span><br><span class="hljs-built_in">memset</span>(&amp;op, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(op));<br><br><span class="hljs-comment">/* 2. 定义凹槽的用途 */</span><br>op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);<br><br><span class="hljs-comment">/* 3. 放入数据 */</span><br>op.params[<span class="hljs-number">0</span>].value.a = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><h4 id="关键点解析："><a href="#关键点解析：" class="headerlink" title="关键点解析："></a>关键点解析：</h4><ol><li><p><strong><code>TEEC_PARAM_TYPES</code> (贴标签)</strong></p><ul><li><p>OP-TEE 规定这个托盘<strong>最多只能放 4 个参数</strong>（param0 ~ param3）。</p></li><li><p>你必须显式地告诉 TA，每个凹槽里放的是什么类型的数据。</p></li><li><p><strong><code>TEEC_VALUE_INOUT</code></strong>：这是最关键的标签。</p><ul><li><p><strong>VALUE</strong>：表示我要传的是简单的<strong>整数</strong>（不是指针&#x2F;内存块）。</p></li><li><p><strong>INOUT</strong>：表示这个数据是<strong>双向</strong>的。“我传进去（IN）给 TA 看，TA 改完后再传出来（OUT）给我看”。</p></li></ul></li><li><p><strong><code>TEEC_NONE</code></strong>：表示这个凹槽我不用，空着。</p></li></ul></li><li><p><strong><code>op.params[0].value.a</code> (放数据)</strong></p><ul><li><p>对应上面的标签，我们在第 0 个凹槽 (<code>params[0]</code>) 里放数据。</p></li><li><p><strong>为什么是 <code>.value.a</code>？</strong></p><ul><li><p>因为 <code>TEEC_Value</code> 类型可以容纳两个整数，分别叫 <code>a</code> 和 <code>b</code>。</p></li><li><p>你可以只用 <code>a</code>，也可以 <code>a</code> 和 <code>b</code> 都用（比如传坐标 x,y 时就很有用）。</p></li></ul></li><li><p>这里我们把 <strong>42</strong> 放进了 <code>a</code> 里。</p></li></ul></li></ol><hr><h3 id="子动作-B：递单子-TEEC-InvokeCommand"><a href="#子动作-B：递单子-TEEC-InvokeCommand" class="headerlink" title="子动作 B：递单子 (TEEC_InvokeCommand)"></a>子动作 B：递单子 (<code>TEEC_InvokeCommand</code>)</h3><p>单子填好了，现在要按下按钮，把它传送进去。</p><p>C</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">/* TA_HELLO_WORLD_CMD_INC_VALUE 是具体的指令代码，比如定义为 0 */</span><br><span class="hljs-attr">res</span> <span class="hljs-operator">=</span> TEEC_InvokeCommand(<span class="hljs-variable">&amp;sess</span>, TA_HELLO_WORLD_CMD_INC_VALUE, <span class="hljs-variable">&amp;op</span>, <span class="hljs-variable">&amp;err_origin</span>)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h4 id="参数拆解："><a href="#参数拆解：" class="headerlink" title="参数拆解："></a>参数拆解：</h4><ol><li><p><strong><code>&amp;sess</code></strong>：</p><ul><li><p>使用你在第二步建立的那个<strong>专属会话</strong>。</p></li><li><p>这确保了指令是发给“Hello World TA”的，而不是隔壁的“加密 TA”。</p></li></ul></li><li><p><strong><code>TA_HELLO_WORLD_CMD_INC_VALUE</code> (Command ID)</strong>：</p><ul><li><p>这是你对柜员喊出的<strong>具体业务名</strong>：“我要办<strong>加法</strong>业务！”</p></li><li><p>TA 那边会有一个大的 <code>switch-case</code> 语句，根据这个 ID 跳转到对应的加法函数。</p></li></ul></li><li><p><strong><code>&amp;op</code></strong>：</p><ul><li>把刚才填好的托盘递进去。</li></ul></li></ol><hr><h3 id="⚠️-数据流动的全过程（穿越时刻）"><a href="#⚠️-数据流动的全过程（穿越时刻）" class="headerlink" title="⚠️ 数据流动的全过程（穿越时刻）"></a>⚠️ 数据流动的全过程（穿越时刻）</h3><p>这是最神奇的地方。当你执行这就话时，CPU 的状态发生了如下变化：</p><ol><li><p><strong>CA 暂停 (Blocking)</strong>：</p><ul><li>你的 <code>main.c</code> 程序在这里<strong>卡住不动了</strong>。它在等待结果。</li></ul></li><li><p><strong>世界切换 (Context Switch)</strong>：</p><ul><li><p>Linux 内核通过驱动发起 SMC (Secure Monitor Call) 指令。</p></li><li><p>CPU 从 <strong>Normal World (Linux)</strong> 切换进 <strong>Secure World (OP-TEE)</strong>。</p></li></ul></li><li><p><strong>TA 接单</strong>：</p><ul><li><p>OP-TEE OS 唤醒 TA，调用 TA 的 <code>TA_InvokeCommandEntryPoint</code>。</p></li><li><p>TA 读取 <code>params[0].value.a</code> (也就是 42)。</p></li><li><p>TA 执行逻辑：<code>val = 42 + 1;</code></p></li><li><p>TA <strong>修改托盘里的数据</strong>：<code>params[0].value.a = 43;</code></p></li><li><p>TA 返回 <code>TEE_SUCCESS</code>。</p></li></ul></li><li><p><strong>CA 恢复</strong>：</p><ul><li><p>CPU 切回 Linux。</p></li><li><p><code>TEEC_InvokeCommand</code> 函数返回。</p></li><li><p>你的程序继续往下走。</p></li></ul></li></ol><hr><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TA incremented value to %d\n&quot;</span>, op.params[<span class="hljs-number">0</span>].value.a);<br></code></pre></td></tr></table></figure><p>此时你去读内存里的 <code>op</code> 结构体，你会发现刚才填进去的 42 已经被<strong>原地篡改</strong>成了 43。</p><p>这就是 <strong>INOUT（双向传递）</strong> 的魔力。</p><h3 id="总结第三步"><a href="#总结第三步" class="headerlink" title="总结第三步"></a>总结第三步</h3><ul><li><p><strong>工具</strong>：<code>TEEC_Operation</code> 是唯一合法的数据载体（托盘）。</p></li><li><p><strong>动作</strong>：<code>TEEC_InvokeCommand</code> 是穿越世界的触发器。</p></li><li><p><strong>效果</strong>：数据进去转了一圈，被 TA 修改后又送了回来。</p></li></ul><p>至此，CA 端（Linux 端）的代码逻辑你已经全部打通了！</p><h3 id="第四步：关闭会话，销毁环境"><a href="#第四步：关闭会话，销毁环境" class="headerlink" title="第四步：关闭会话，销毁环境"></a><strong>第四步：关闭会话，销毁环境</strong></h3><h3 id="1-TEEC-CloseSession-sess"><a href="#1-TEEC-CloseSession-sess" class="headerlink" title="1. TEEC_CloseSession(&amp;sess)"></a>1. <code>TEEC_CloseSession(&amp;sess)</code></h3><p><strong>对应步骤</strong>：<code>TEEC_OpenSession</code> <strong>比喻</strong>：办完业务了，<strong>离开柜台</strong>。</p><ul><li><p><strong>它的作用</strong>： 告诉 OP-TEE：“我和这个 TA (Hello World) 的这次对话结束了。”</p></li><li><p><strong>发生了什么？（连锁反应）</strong></p><ol><li><p><strong>CA 端</strong>：标记 <code>sess</code> 结构体失效，你不能再用它发指令了。</p></li><li><p><strong>穿越世界</strong>：系统发送信号给 Secure World。</p></li><li><p><strong>TA 端（关键）</strong>：</p><ul><li><p>OP-TEE OS 会调用 TA 里的回调函数 <strong><code>TA_CloseSessionEntryPoint</code></strong>。</p></li><li><p><strong>这一步非常重要！</strong> 假如 TA 在为你服务的过程中申请了堆内存（malloc），它必须在这个回调函数里释放掉。如果你不调用 <code>CloseSession</code>，TA 那边的内存可能就一直被占着，变成**“僵尸内存”**。</p></li></ul></li></ol></li></ul><hr><h3 id="2-TEEC-FinalizeContext-ctx"><a href="#2-TEEC-FinalizeContext-ctx" class="headerlink" title="2. TEEC_FinalizeContext(&amp;ctx)"></a>2. <code>TEEC_FinalizeContext(&amp;ctx)</code></h3><p><strong>对应步骤</strong>：<code>TEEC_InitializeContext</code> <strong>比喻</strong>：把通行证还给大堂经理，<strong>走出银行大门</strong>。</p><ul><li><p><strong>它的作用</strong>： 彻底断开你的应用程序 (CA) 与 OP-TEE 驱动之间的连接。</p></li><li><p><strong>发生了什么？</strong></p><ol><li><p><strong>销毁资源</strong>：它会释放 <code>ctx</code> 结构体里分配的内存。</p></li><li><p><strong>关闭文件</strong>：</p><ul><li><p>还记得我们之前说的 <code>fd</code> (文件描述符) 吗？</p></li><li><p>这个函数底层会执行 <code>close(ctx-&gt;fd)</code>。</p></li><li><p>这等于挂断了通往内核驱动的电话线。</p></li></ul></li></ol></li></ul><hr><h3 id="为什么要这么繁琐？（资源泄漏的后果）"><a href="#为什么要这么繁琐？（资源泄漏的后果）" class="headerlink" title="为什么要这么繁琐？（资源泄漏的后果）"></a>为什么要这么繁琐？（资源泄漏的后果）</h3><p>想象一下，如果你写了一个 App，要在后台一直运行（比如指纹服务），并且你每次用完都不关 Session：</p><ol><li><p>你申请了 Session 1，占用了一点 TEE 内存。</p></li><li><p>你申请了 Session 2，又占用了一点。</p></li><li><p>…</p></li><li><p><strong>崩溃</strong>：OP-TEE 的内存是非常有限的（通常只有几 MB 到几十 MB）。很快，OP-TEE 就会报 <code>TEE_ERROR_OUT_OF_MEMORY</code>，导致整个安全功能瘫痪，甚至可能导致系统重启。</p></li></ol><h3 id="总结-CA-端的“四部曲”"><a href="#总结-CA-端的“四部曲”" class="headerlink" title="总结 CA 端的“四部曲”"></a>总结 CA 端的“四部曲”</h3><p>到现在为止，你已经完整复盘了 CA (Host) 端的生命周期：</p><ol><li><p><strong>Initialize</strong>: 进门（拿 fd）。</p></li><li><p><strong>OpenSession</strong>: 找人（连 UUID，触发 TA 的 <code>OpenSession</code>）。</p></li><li><p><strong>InvokeCommand</strong>: 办事（传 INOUT 参数，触发 TA 的 <code>InvokeCommand</code>）。</p></li><li><p><strong>Close &amp; Finalize</strong>: 走人（触发 TA 的 <code>CloseSession</code>，释放 fd）。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OPTEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TA快速入门</title>
    <link href="/2025/11/25/2%E3%80%81TA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2025/11/25/2%E3%80%81TA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="头文件：hello-world-ta-h"><a href="#头文件：hello-world-ta-h" class="headerlink" title="头文件：hello_world_ta.h"></a>头文件：hello_world_ta.h</h3><p>这两个头文件定义了 TA 的“身份证”和“基本素质”。</p><h4 id="1-hello-world-ta-h-——-CA-和-TA-的共同语言"><a href="#1-hello-world-ta-h-——-CA-和-TA-的共同语言" class="headerlink" title="1. hello_world_ta.h —— CA 和 TA 的共同语言"></a>1. <code>hello_world_ta.h</code> —— CA 和 TA 的共同语言</h4><p>这个文件最重要，因为它<strong>既被 CA 包含，也被 TA 包含</strong>。它是两边通讯的契约。</p><ul><li><strong>身份证号</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TA_HELLO_WORLD_UUID ...</span><br></code></pre></td></tr></table></figure><p>这就是我们之前反复提到的 UUID。CA 必须要用这个号才能找到 TA。</p><ul><li><strong>指令暗号</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TA_HELLO_WORLD_CMD_INC_VALUE0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TA_HELLO_WORLD_CMD_DEC_VALUE1</span><br></code></pre></td></tr></table></figure><p>这里定义了 TA 能听懂的两个指令：<strong>0 (加法)</strong> 和 <strong>1 (减法)</strong>。 _注意：我们在刚才的 CA 代码里只用了 0 (INC)，但其实 TA 已经默默支持了 1 (DEC)！这意味着你只需要改改 CA 就能做减法了。</p><h4 id="user-ta-header-defines-h-——-给编译器看的配置"><a href="#user-ta-header-defines-h-——-给编译器看的配置" class="headerlink" title="user_ta_header_defines.h —— 给编译器看的配置"></a><code>user_ta_header_defines.h</code> —— 给编译器看的配置</h4><p>这个文件主要告诉 OP-TEE OS 如何加载这个 TA。</p><ul><li><strong>堆栈大小</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TA_STACK_SIZE(2 * 1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TA_DATA_SIZE(32 * 1024)</span><br></code></pre></td></tr></table></figure>  TA 也是个程序，它需要内存。这里预留了 <strong>2KB 的栈</strong>（存局部变量）和 <strong>32KB 的堆</strong>（用于 malloc）。嵌入式资源宝贵，这两个值不能瞎填。</li></ul><h3 id="TA流程"><a href="#TA流程" class="headerlink" title="TA流程"></a><strong>TA流程</strong></h3><p>其实 TA 的生命周期就像一家 <strong>“只为 VIP 服务的餐厅”</strong>：</p><ol><li><p><strong>开店 (Create)</strong>：餐厅开门，准备食材（初始化）。</p></li><li><p><strong>迎宾 (OpenSession)</strong>：客人进门，安排座位（建立会话）。</p></li><li><p><strong>上菜 (InvokeCommand)</strong>：客人点菜，厨师做菜（处理指令）。</p></li><li><p><strong>送客与打烊 (CloseSession &amp; Destroy)</strong>：客人买单走人，或者最后关店（清理资源）。</p></li></ol><p>我们结合代码来看看每一个步骤具体做了什么。</p><hr><h3 id="第一步：开店-——-TA-CreateEntryPoint"><a href="#第一步：开店-——-TA-CreateEntryPoint" class="headerlink" title="第一步：开店 —— TA_CreateEntryPoint"></a>第一步：开店 —— <code>TA_CreateEntryPoint</code></h3><p>这是 TA 被加载到 OP-TEE 内存时执行的第一个函数。</p><p><strong>代码位置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Called when the instance of the TA is created. This is the first call in the TA. */</span><br>TEE_Result <span class="hljs-title function_">TA_CreateEntryPoint</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DMSG(<span class="hljs-string">&quot;has been called&quot;</span>);<br>    <span class="hljs-keyword">return</span> TEE_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>触发时机：</p><p>  当 第一个 CA 试图连接这个 TA，且这个 TA 还没在内存里的时候。系统会把 TA 文件从磁盘读入内存，然后立刻调用这个函数。</p><p>  注意：如果后续还有别的 CA 连进来，只要 TA 还在内存里，这个函数就不会再跑了（这叫单实例 Multi-Session）。</p></li><li><p>代码行为：</p><p>  在 hello_world 里，它只打了一条调试日志（DMSG）。</p></li><li><p>作用：</p><p>  做 全局初始化。比如：如果你是一个加密 TA，你可能在这里初始化硬件加密引擎；如果你需要管理全局状态（比如统计总共有多少人连进来了），也在这里初始化。</p></li></ul><hr><h3 id="第二步：迎宾-——-TA-OpenSessionEntryPoint"><a href="#第二步：迎宾-——-TA-OpenSessionEntryPoint" class="headerlink" title="第二步：迎宾 —— TA_OpenSessionEntryPoint"></a>第二步：迎宾 —— <code>TA_OpenSessionEntryPoint</code></h3><p>这是每一个 CA 想要“连线”时都会触发的函数。</p><p><strong>代码位置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">TEE_Result <span class="hljs-title function_">TA_OpenSessionEntryPoint</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> param_types,</span><br><span class="hljs-params">                                    TEE_Param __unused params[<span class="hljs-number">4</span>],</span><br><span class="hljs-params">                                    <span class="hljs-type">void</span> __unused **sess_ctx)</span><br>&#123;<br>    <span class="hljs-comment">/* 1. 检查 CA 带来的东西合不合规 */</span><br>    <span class="hljs-type">uint32_t</span> exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE, ...);<br>    <span class="hljs-keyword">if</span> (param_types != exp_param_types)<br>        <span class="hljs-keyword">return</span> TEE_ERROR_BAD_PARAMETERS;<br><br>    <span class="hljs-comment">/* 2. 打个招呼 */</span><br>    IMSG(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> TEE_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>触发时机：</p><p>  对应 CA 端的 TEEC_OpenSession。每来一个新 CA，就跑一次。</p></li><li><p>关键参数 void **sess_ctx：</p><p>  注意这个参数。这是一个**“便签纸”。你可以在这里申请一块内存，存一些关于这个特定 CA** 的信息（比如他的 ID、他目前的处理进度）。以后这个 CA 再发指令时，系统会把这张“便签纸”递回给你。</p></li><li><p><strong>代码行为</strong>：</p><ol><li><p><strong>权限检查</strong>：它检查了 <code>param_types</code>，确保 CA 在建立连接阶段没有偷偷塞数据进来（全是 <code>TEE_PARAM_TYPE_NONE</code>）。</p></li><li><p><strong>日志</strong>：打印了 “Hello World!”。</p></li></ol></li><li><p>作用：</p><p>  决定是否接受这个客人。返回 TEE_SUCCESS 表示欢迎，返回错误码则直接拒之门外。</p></li></ul><hr><h3 id="第三步：上菜-——-TA-InvokeCommandEntryPoint"><a href="#第三步：上菜-——-TA-InvokeCommandEntryPoint" class="headerlink" title="第三步：上菜 —— TA_InvokeCommandEntryPoint"></a>第三步：上菜 —— <code>TA_InvokeCommandEntryPoint</code></h3><p>这是最核心的业务处理环节。</p><p><strong>代码位置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">TEE_Result <span class="hljs-title function_">TA_InvokeCommandEntryPoint</span><span class="hljs-params">(<span class="hljs-type">void</span> __unused *sess_ctx,</span><br><span class="hljs-params">                                      <span class="hljs-type">uint32_t</span> cmd_id,</span><br><span class="hljs-params">                                      <span class="hljs-type">uint32_t</span> param_types,</span><br><span class="hljs-params">                                      TEE_Param params[<span class="hljs-number">4</span>])</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (cmd_id) &#123;<br>    <span class="hljs-keyword">case</span> TA_HELLO_WORLD_CMD_INC_VALUE: <span class="hljs-comment">// 对应 ID 0</span><br>        <span class="hljs-keyword">return</span> inc_value(param_types, params);<br>    <span class="hljs-keyword">case</span> TA_HELLO_WORLD_CMD_DEC_VALUE: <span class="hljs-comment">// 对应 ID 1</span><br>        <span class="hljs-keyword">return</span> dec_value(param_types, params);<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> TEE_ERROR_BAD_PARAMETERS;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>触发时机：</p><p>  对应 CA 端的 TEEC_InvokeCommand。</p></li><li><p>分发逻辑：</p><p>  它使用一个 switch 语句，根据 CA 传来的 cmd_id 将任务分发给具体的工人函数（inc_value 或 dec_value）。</p></li><li><p><strong>具体干活 (<code>inc_value</code>)</strong>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> TEE_Result <span class="hljs-title function_">inc_value</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> param_types, TEE_Param params[<span class="hljs-number">4</span>])</span><br>&#123;<br>    <span class="hljs-comment">// ... 省略类型检查 ...</span><br>    IMSG(<span class="hljs-string">&quot;Got value: %u from NW&quot;</span>, params[<span class="hljs-number">0</span>].value.a);<br>    params[<span class="hljs-number">0</span>].value.a++;  <span class="hljs-comment">// 核心业务：加 1</span><br>    IMSG(<span class="hljs-string">&quot;Increase value to: %u&quot;</span>, params[<span class="hljs-number">0</span>].value.a);<br>    <span class="hljs-keyword">return</span> TEE_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>  它直接读取并修改了 <code>params</code> 里的值。因为 <code>params</code> 是共享内存的映射，这里的修改在 CA 那边是立即可见的。</p></li></ul><hr><h3 id="第四步：送客与打烊"><a href="#第四步：送客与打烊" class="headerlink" title="第四步：送客与打烊"></a>第四步：送客与打烊</h3><p>这里其实包含了两个函数，分别对应“单个会话结束”和“整个程序退出”。</p><h4 id="4-1-送客-——-TA-CloseSessionEntryPoint"><a href="#4-1-送客-——-TA-CloseSessionEntryPoint" class="headerlink" title="4.1 送客 —— TA_CloseSessionEntryPoint"></a>4.1 送客 —— <code>TA_CloseSessionEntryPoint</code></h4><p><strong>代码位置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TA_CloseSessionEntryPoint</span><span class="hljs-params">(<span class="hljs-type">void</span> __unused *sess_ctx)</span><br>&#123;<br>    IMSG(<span class="hljs-string">&quot;Goodbye!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>触发时机</strong>：对应 CA 端的 <code>TEEC_CloseSession</code>。</p></li><li><p><strong>作用</strong>：清理<strong>本次会话</strong>产生的垃圾。</p><ul><li><p>还记得在 OpenSession 里提到的 <code>sess_ctx</code>（便签纸）吗？如果你在那里 <code>malloc</code> 了内存，<strong>必须在这里 <code>free</code> 掉</strong>，否则就会内存泄漏。</p></li><li><p><code>hello_world</code> 例子很简单，没申请内存，所以只打印了 “Goodbye!”。</p></li></ul></li></ul><h4 id="4-2-打烊-——-TA-DestroyEntryPoint"><a href="#4-2-打烊-——-TA-DestroyEntryPoint" class="headerlink" title="4.2 打烊 —— TA_DestroyEntryPoint"></a>4.2 打烊 —— <code>TA_DestroyEntryPoint</code></h4><p><strong>代码位置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TA_DestroyEntryPoint</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DMSG(<span class="hljs-string">&quot;has been called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>触发时机：</p><p>  当最后一个连接这个 TA 的 CA 断开连接后，OP-TEE 系统觉得“这个 TA 闲着也是浪费内存”，决定把它卸载掉时。</p></li><li><p>作用：</p><p>  清理全局资源（比如关闭硬件设备、保存数据到安全存储等）。对应 TA_CreateEntryPoint 里的操作。</p></li></ul><hr><h3 id="总结图谱"><a href="#总结图谱" class="headerlink" title="总结图谱"></a>总结图谱</h3><table><thead><tr><th><strong>步骤</strong></th><th><strong>TA 函数名</strong></th><th><strong>对应 CA 动作</strong></th><th><strong>现实比喻</strong></th><th><strong>核心任务</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><code>TA_CreateEntryPoint</code></td><td>(无直接对应，系统自动触发)</td><td><strong>餐厅开门</strong></td><td>全局初始化 (只跑一次)</td></tr><tr><td><strong>2</strong></td><td><code>TA_OpenSessionEntryPoint</code></td><td><code>TEEC_OpenSession</code></td><td><strong>迎宾入座</strong></td><td>检查权限，建立私有会话数据</td></tr><tr><td><strong>3</strong></td><td><code>TA_InvokeCommandEntryPoint</code></td><td><code>TEEC_InvokeCommand</code></td><td><strong>点菜上菜</strong></td><td>识别 Command ID，执行具体逻辑 (加减法)</td></tr><tr><td><strong>4</strong></td><td><code>TA_CloseSessionEntryPoint</code></td><td><code>TEEC_CloseSession</code></td><td><strong>买单送客</strong></td><td>释放会话内存 (清理 sess_ctx)</td></tr><tr><td><strong>End</strong></td><td><code>TA_DestroyEntryPoint</code></td><td>(无直接对应，系统自动触发)</td><td><strong>打烊关门</strong></td><td>释放全局资源</td></tr></tbody></table><img src="/2025/11/25/2%E3%80%81TA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/%E5%9B%BE.png" class="">]]></content>
    
    
    <categories>
      
      <category>技术研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OPTEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TEEOS浅谈</title>
    <link href="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/"/>
    <url>/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/</url>
    
    <content type="html"><![CDATA[<p>内容来自前辈的文章，链接已经放在文末。</p><h2 id="一、前言-TEE-OS都有哪些厂商"><a href="#一、前言-TEE-OS都有哪些厂商" class="headerlink" title="一、前言-TEE OS都有哪些厂商"></a>一、前言-TEE OS都有哪些厂商</h2><p>伴随着Android的发展，TEEOS已成为端侧的基础安全平台，其提供的安全能力为指纹、人脸、支付等多个安全相关的业务服务，而如今都有哪些厂商在做TEE OS呢？</p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/356622171ae86bffa27bc8efa2e1de26.png" class="" title="在这里插入图片描述"><p>这里列出了18个TEEOS的厂商，在Android手机搭载的TEEOS中，高通的QSEE占比35%、Trustonic&amp;TEEgris占比20%、华为的iTrustee占比17%。下面就基于各个手机厂商的选型来对比一下各个TEE OS解决方案。</p><h3 id="1、小米"><a href="#1、小米" class="headerlink" title="1、小米"></a>1、小米</h3><p>小米搭载的是高通和MTK的芯片，其TEE OS能力非自研，高通采用的QSEE，MTK采用的是trustonic，但是各个TEE之间兼容性、开放性等等的问题，造成了安全应用的生态闭塞，制约了安全业务的发展。高通QSEE芯片整合能力强，并增加了SPU（Secure Processing Unit）处理器，实现了更高级别的安全，但是其开放性较差，只支持高通芯片，生态业务支持性不好。</p><p>反观trustonic，其通过跨平台的SDK屏蔽设备差异，芯片差异，提供应用一致性的编程接口和工具，因此其生态应用拓展丰富，但落地困难，导致应用受限。</p><h3 id="2、华为"><a href="#2、华为" class="headerlink" title="2、华为"></a>2、华为</h3><p>华为搭载的芯片包括hisi、高通、MTK，采用的iTrustee解决方案，其面向的是全场景，正在成为HMS（华为移动服务）安全生态竞争力基础。</p><p>即使有多种规格的设备，通过可信业务接口适配层屏蔽了其差异，实现了接口的归一，从而各个安全业务可以无缝迁移到各个终端设备和平台，实现了跨平台、跨芯片部署，其开放性和兼容性满足了应用的全场景诉求。</p><h3 id="3、三星"><a href="#3、三星" class="headerlink" title="3、三星"></a>3、三星</h3><p>三星TEEOS从初期的QSEE+Trustonic逐步走向自研化，当前部分芯片已经支持其自研的TEEgris，并对外发布SDK，其TEE OS分为自研和外购两种，同样制约了安全业务的发展，安全生态还处于初期阶段。</p><h3 id="4、Google"><a href="#4、Google" class="headerlink" title="4、Google"></a>4、Google</h3><p>Google也推出了Android原生配套的TEE OS：Trusty，作为一种可靠且免费的开源替代方案提供给合作伙伴，用于替代其可信执行环境。但是Trusty不支持三方应用开发，其应用只能各个厂商封装在Trusty内核中，再加上Google没有自研的芯片支持，因此生态发展缓慢。</p><h3 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h3><p>TEEOS目前有如此多的厂商在做，但是之间互不兼容，出于各自为政的状态，已经进入存量发展的阶段，其市场份额和手机占比正相关，碎片化及其严重。</p><p>虽然有GP规范定义行业标准，但是规范滞后于行业的发展，且封闭繁琐不完整，从而手机厂商参与度不足，没有一家能够完全遵循GP，导致落地困难。再加上垂直的行业联盟，只聚焦于特定的技术方案，没有解决碎片化和易用性的问题，导致安全应用只能在部分高端芯片、高端手机上应用，无法做大安全生态。</p><p>因此在全场景的大背景下，以保证安全为前提，只有解决了平台之间、芯片之间的兼容性问题和安全应用的生态开放问题，才能做到安全应用的全场景部署和无缝迁移，从而生态才能够健康的发展。而国家正在着手制定行业标准，《信息安全技术 可信执行环境系统架构》正在征求意见稿，《信息安全技术 可信执行环境服务规范》正在开始制定，可信执行环境国家系列标准有望从顶层设计规范未来技术发展。</p><h2 id="二、为什么说GP没有解决TEEOS生态碎片化"><a href="#二、为什么说GP没有解决TEEOS生态碎片化" class="headerlink" title="二、为什么说GP没有解决TEEOS生态碎片化"></a>二、为什么说GP没有解决TEEOS生态碎片化</h2><p>通常意义上，大家都认为GP是TEE行业发展过程中一个重要的组织。</p><p>如下图所示GP各种数据展示其经过20多年的发展，90多位会员企业，主要聚焦于SE、TEE、TPS三个方向。</p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/6277dc3fad217c6b5d6f65ae0dc74f5e.png" class="" title="在这里插入图片描述">  <p>但GP实际一共只有85家会员单位。大部分都是传统卡商，SE芯片厂商，测试认证厂商等等。（<a href="https://globalplatform.org/current-members/%EF%BC%89">https://globalplatform.org/current-members/）</a></p><p>GP目标是：Develop once and deploy everywhere 一次开发，随意部署！</p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/3099e0e7023d31f219a8b3ddf8dea45c.png" class="" title="在这里插入图片描述">  <p>但实际上，从2010年发布第一版API以来，碎片化反而有增无减。</p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/8b6745f05c119bad34638b562acbec40.png" class="" title="在这里插入图片描述">  <p>GP不是以设备厂商角度来思考标准体系建设,不是以系统架构思想来构建标准体系。</p><p>GP在智能卡领域是绝对的权威，这点不假，可是智能卡是一个强监管、封闭实体，与端侧不一样。硬件SE与Trustzone不一样，同样：TEEOS也与COS不同。TEEOS有着强烈的生态开放属性，其生态业务更有着更强算力资源需求。TEEOS与REE侧OS相互关联密切，有着更强的系统安全属性。而不仅仅是一个独立的SE芯片，不基于设备厂商生态思维，从而导致GP制定的一些标准基本从传统智能卡出发经验，不符合移动互联网时代应用生态业务需求和编程习惯。</p><p>GP标准滞后于行业发展，比如对TUI接口的支持严重滞后，各TEEOS厂商自己实现私有接口。比如，对有生物识别等硬件接口支持严重滞后，导致各指纹厂商针对高通平台一套实现，麒麟一套实现，还要适配trustonic…豆荚…苦不堪言！</p><p>GP直到2018年10月份才更新发布生物识别、外部接口等。而指纹相关应用在2016年已经对TEE有明确诉求，各家只能按照自己的方式去实现接口，何谈兼容！</p><p>GP标准封闭繁琐，遵循智能卡体系， TA应用生命周期管理商业模式不明确，接口难用，应用困难。比如，安全应用管理混乱不堪，安全管理框架TMF，之前是叫TA admin,弄了好多年，最近总算与OTrP融合了一版。</p><p>比如，各应用厂商都需要定义自己的DeviceID格式,因为GP只有UUID，没有设备的概念。</p><p>GP沿用智能卡概念设计太多，不实用不够友好。比如简单的文件存储，干嘛非要persist object？直接文件不就完了？开发者开发TA最后还又要封装成 fs_open read write close…</p><p>GP标准未能反映技术发展趋势，目前没有一家TEE厂商能严格遵守了GP规范，不是不愿意，而且业务需求根本不满足不了，因为卡片操作系统不需要人机交互界面，不需要生态业务。比如，没有定义TA编译配置环境规范，导致各家不兼容，一个指纹厂商要同时针对多家TEEOS开发不同版本的指纹安全应用。比如，没有定义端云一体规范，没有定义云端TEE框架,无法适应未来云端可信执行环境下的安全需求。</p><p>GP标准落地约束性不足，安全厂商利益角逐，手机厂商参与度不足，落地困难。除了三星，苹果这些超级大公司之外，广大的手机厂商小米，OPPO，VIVO等手机厂商都没有参与。目前TEE主要部署在手机上，手机终端厂商有着很大的利益诉求，可GP的话语权体系目前并不在终端厂商。</p><p>总之，由于GP规范自身问题甚至加重了各厂商存在大量私有API的情况，虽然说后来GP也推出TPS的目的是想统一端云标准，但是其标准本身的碎片化并没有很好解决，而是头痛医头脚痛医脚。</p><p>因此GP无法解决生态能力开放体系化，标准化问题。</p><p>（这倒是打开了我的新的认知）</p><h2 id="三、TEE成为央行支付产品种类"><a href="#三、TEE成为央行支付产品种类" class="headerlink" title="三、TEE成为央行支付产品种类"></a>三、TEE成为央行支付产品种类</h2><p>央行发布的《条码支付业务规范（试行）》的通知，包括三个文件：</p><p>《条码支付业务规范（试行）》</p><p>《条码支付安全技术规范（试行）》</p><p>《条码支付受理终端技术规范（试行）》</p><p>解读的文章众多，今天这里从技术方面进行学习：</p><p>首先我们来看看， 中国人民银行就发布条码支付规范答记者问中有如下</p><p>问：针对条码支付技术风险，提出了哪些针对性要求？</p><p>答：一是加强条码安全防护。采取支付标记化（Tokenization）、有效期控制、条码防伪识别等手段，提升条码生成、存储、展示、识读、解析、使用等环节的安全防护能力，有效保障条码的可靠性和有效性。</p><p>二是提升条码支付交易安全强度。针对不同条码生成方式，提出加密生成、定期更新、终端唯一标识绑定等具有针对性的安全防护措施。要求银行、支付机构和清算机构运用交易验证强度与交易额度相匹配的技术措施提高条码支付交易的安全性。</p><p>三是强化条码支付交易风险监测与预警。合理应用大数据分析、用户行为建模等手段建立条码支付风险监控模型和系统，对异常交易及时预警并附加风控措施，对高风险交易及时告知客户资金变化情况。</p><p>四是加强客户端软件安全管理。从木马病毒防范、信息加密保护、运行环境可信等方面提升条码支付客户端软件的安全防护能力，要求客户端软件能够监测并向后台系统反馈手机支付环境安全状况并作为风控策略的依据。</p><p>这里面明确了提示条码生成、存储、展示、识读、解析等环节的安全防护能力，以及客户端软件的可信环境安全防护能力。</p><p>我们知道TEE+SE的基础能力天然具备上述要求，比如应用条码的生成、存储可以在TEE环境中，展示、识读可以在TUI页面完成。</p><p>我们理解的客户端软件的可信环境安全防护能力指的是TEE或者SE，目前Android手机上如果不基于TEE技术是无法“可信”！</p><p>再来看看《条码支付受理终端技术规范（试行）》：  </p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/dc2174cd8323fa49b1e3b4e53ea3fb61.png" class="" title="在这里插入图片描述"><p>也就是说后期的终端设备是强制要求使用TEE或者SE的，我们不难看出</p><img src="/2025/11/24/TEEOS%E7%9A%84%E4%B8%80%E7%82%B9%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD_local/2a21f1a1938f5cad9399d3c294def79a.png" class="" title="在这里插入图片描述"><p>各位同仁看到这里，大家是否明白了什么呢？</p><p>1，央行出台了条码支付规范，要求2018年4月1日起实施。</p><p>2，中国支付清算协会明出台了支付产品种类，同时明确了引用的标准。2018年1月1日起实施。</p><p>3，中国支付清算协会业务主管单位为中国人民银行。</p><p>安全已经提示到国家战略层门，央行已经在支付产品安全的具体落实方面，包括在安全技术、产品规范、技术标准等方面对TEE、SE等可信执行环境做出了明确的指示。</p><p>参考链接：<br><a href="https://developer.huawei.com/consumer/cn/forum/topic/0201884414394540189?fid=0102501639476130680">https://developer.huawei.com/consumer/cn/forum/topic/0201884414394540189?fid=0102501639476130680</a><br><a href="https://developer.huawei.com/consumer/cn/forum/topic/0202506006826340101?fid=0102501639476130680">https://developer.huawei.com/consumer/cn/forum/topic/0202506006826340101?fid=0102501639476130680</a></p>]]></content>
    
    
    <categories>
      
      <category>技术研究</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TEE</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
